import json
import math
import re
import sys
from git import Repo
from git.diff import Diff
from pathlib import Path
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
import os

def continguous_zip(l: list):
  """generated by gpt
  
  generates pairs given list
  Example:
    [a,b,c,d]
  
  Returns
    [(a,b), (b,c), (c,d)]
  """
  return list(zip(l[:-1], l[1:]))

def get_diff_file(diff: Diff) -> str:
  if diff.a_blob:
      return diff.a_blob.path
  elif diff.b_blob:
      return diff.b_blob.path


# NOTE do not have support for h,m,s,ms,ns
allowed_time_units = ["d", "m", "y"] 

def extract_number(date_expr: str) -> int:
  found = re.match(rf'(-?\d+)({"|".join(allowed_time_units)})', date_expr)
  if found:
    return int(found.group(1))
  else:
    raise ValueError("date expr does not conform to regex and or allowed time units")



def parse_relative_time_expr(date_expr: str):
  number = abs(extract_number(date_expr))
  match(date_expr):
    case _ if date_expr.endswith("d"):
      return datetime.now() - relativedelta(days=number)
    case _ if date_expr.endswith("m"):
      return datetime.now() - relativedelta(months=number)
    case _ if date_expr.endswith("y"):
      return datetime.now() - relativedelta(years=number)
    case _ :
      raise ValueError(f"Cannot Parse date_expr {date_expr}")
  
def parse_date_expr(date_expr: str):
  """
  Args:
    date_expr: str
      Examples:
        relative_time:
          7d
          12m
          100y
  """
  is_relative_time_expr = any([date_expr.endswith(unit) for unit in allowed_time_units])
  if is_relative_time_expr:
    # is relative time expr
    return parse_relative_time_expr(date_expr)
  raise ValueError("Only Relative Time Expressions can be parsed right now")


def get_commits(repo: Repo, date_expr: str = None):
  start_time_interval = parse_date_expr(date_expr)
  for commit in repo.iter_commits():
    if datetime.fromtimestamp(commit.committed_date) >= start_time_interval:
      yield commit
    else:
      break

#####################################
# hashmap                           #
# key: filepath                     #
# value: tally of number of changes #
#####################################
occurence_map = {}


if __name__ == "__main__":
  # get where user is executing the script
  execution_path = os.getcwd()

  # input path relative to the CWD the user is in when executing the script
  relative_path = sys.argv[1]

  # relative to the user's execution context
  path = os.path.join(execution_path, relative_path)

  # try to initialise given path as a git repo object
  repo = Repo(path)
  
  # fetches commits based off a parsable date_expression
  commits = list(get_commits(repo, date_expr="12m"))
  if len(commits) < 1:
    raise ValueError("this repo does not have any commits")
  
  # calculate the diffs between each contiguous commits
  # and tally up all file changes
  for pairs in continguous_zip(commits):
    c1, c2 = pairs
    # git.diff.Diff
    # https://gitpython.readthedocs.io/en/stable/reference.html?highlight=git.diff.Diff#git.diff.Diff
    diffs = c1.diff(c2)
    for diff in diffs:
      file_path = get_diff_file(diff)
      
      if file_path not in occurence_map:
        occurence_map[file_path] = 1
      else:
        occurence_map[file_path] += 1

  
  # now calculate frequency based off total file changes
  total_file_changes = sum(occurence_map.values())
  frequency_map = { key: value/total_file_changes for key, value in occurence_map.items() }
  frequency_map_sorted = dict(sorted(frequency_map.items(), key=lambda item: item[1]))

  # prints frequency sorted
  print(json.dumps(
    frequency_map_sorted,
    indent=2
  ))